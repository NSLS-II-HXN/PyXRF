# ######################################################################
# Copyright (c) 2014, Brookhaven Science Associates, Brookhaven        #
# National Laboratory. All rights reserved.                            #
#                                                                      #
# Redistribution and use in source and binary forms, with or without   #
# modification, are permitted provided that the following conditions   #
# are met:                                                             #
#                                                                      #
# * Redistributions of source code must retain the above copyright     #
#   notice, this list of conditions and the following disclaimer.      #
#                                                                      #
# * Redistributions in binary form must reproduce the above copyright  #
#   notice this list of conditions and the following disclaimer in     #
#   the documentation and/or other materials provided with the         #
#   distribution.                                                      #
#                                                                      #
# * Neither the name of the Brookhaven Science Associates, Brookhaven  #
#   National Laboratory nor the names of its contributors may be used  #
#   to endorse or promote products derived from this software without  #
#   specific prior written permission.                                 #
#                                                                      #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    #
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS    #
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE       #
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,           #
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES   #
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR   #
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   #
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  #
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OTHERWISE) ARISING   #
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   #
# POSSIBILITY OF SUCH DAMAGE.                                          #
########################################################################

import numpy as np

from enaml.widgets.api import (Container, PushButton, Label,
                               Form, Field, FileDialogEx, DockItem,
                               DockArea, CheckBox, ComboBox,
                               ScrollArea, Window, GroupBox)
from enaml.layout.api import hbox, vbox, HSplitLayout, VSplitLayout, spacer
from auto_enaml.api import AutoView
from enaml.stdlib.fields import FloatField
from enaml.layout.geometry import Box

from bubblegum.xrf.model.fit_spectrum import Param

enamldef FitView(DockItem): fit_view:
    attr io_model
    attr param_model
    attr plot_model
    attr fit_model

    Container:
        constraints = [
            vbox(
                param_gb,
                lbl0,
                hbox(lbl1, cb1, spacer),
                hbox(lbl2, cb2, spacer),
                hbox(lbl3, cb3, spacer),
                hbox(pb_fit, pb_plot, spacer),
                hbox(btn_edit, spacer),
            ),
        ]
        GroupBox: param_gb:
            constraints = [
                vbox(
                    hbox(pb_previous, pb_param, spacer),
                    hbox(param_status, spacer),
                ),
            ]
            PushButton: pb_previous:
                text = 'Import Parameters'
                clicked ::
                    fit_model.param_dict = param_model.param_new
                    param_status.text = 'Use fitting parameters from previous step.'
            PushButton: pb_param:
                text = 'Import Parameters from File'
                clicked ::
                    param_path = FileDialogEx.get_open_file_name(fit_view)
                    if param_path:
                        fit_model.file_path = param_path
                        param_status.text = fit_model.file_status
            Label: param_status:
                text = 'No file is loaded.'
        Label: lbl0:
            text = 'Fitting Strategy'
        Label: lbl1:
            text = 'Step 1'
        ComboBox: cb1:
            items = ['', 'fit_with_tail', 'free_more', 'e_calibration', 'linear']
            index = 0
            index >> fit_model.fit_strategy1
            #index ::
            #    print('use strategy 1: {}'.format(fit_m.fit_strategy1))
        Label: lbl2:
            text = 'Step 2'
        ComboBox: cb2:
            items = ['', 'fit_with_tail', 'free_more', 'e_calibration', 'linear']
            index = 0
            index >> fit_model.fit_strategy2
            #index ::
            #    print('use strategy 2: {}'.format(fit_model.fit_strategy2))
        Label: lbl3:
            text = 'Step 3'
        ComboBox: cb3:
            items = ['', 'fit_with_tail', 'free_more', 'e_calibration', 'linear']
            index = 0
            index >> fit_model.fit_strategy3
            #index ::
            #    print('use strategy 3: {}'.format(fit_model.fit_strategy3))
        PushButton: pb_fit:
            text = 'Fit'
            clicked ::
                #fit_model.fit_data()
                fit_model.fit_multiple()
                pb_plot.enabled = True
                plot_model.fit_x = fit_model.fit_x
                plot_model.fit_y = fit_model.fit_y
                plot_model.fit_all = fit_model.comps
                plot_model.residual = fit_model.residual
                plot_model.plot_fit()
        PushButton: pb_plot:
            text = 'Overlap to Spectrum'
            checkable = True
            enabled = False
            clicked ::
                if checked:
                    plot_model.show_fit_opt = True
                    pb_plot.text = 'Remove Plot'
                else:
                    plot_model.show_fit_opt = False
                    pb_plot.text = 'Overlap to Spectrum'

        PushButton: btn_edit:
            text = 'Edit Defaults'
            clicked ::
                #ParameterEdit_old.parameter_model = fit_model.param_dict
                #ParameterEdit_old.param = Param
                #ParameterEdit_old().show()
                #param_model.get_param(param_model.param_new)
                param_model.get_param(fit_model.param_dict)
                ParameterEdit.parameter_model = param_model
                ParameterEdit().show()


enamldef ParameterEdit(Window):
    attr parameter_model
    destroy_on_close = False
    Container:
        padding = Box(5, 5, 5, 5)
        ComboBox: cmb:
            items << sorted(parameter_model.parameters.keys())
            selected_item ::
                av.model = parameter_model.parameters[selected_item]
        AutoView: av:
            model = parameter_model.parameters.values()[0]
            padding = 10
        PushButton: save:
            text = "Save changes to disk"
            clicked ::
                parameter_model.save()
                #save_defaults(parameter_model)


def save_defaults(parameter_model):
    user_path = os.path.join(os.path.expanduser('~'), '.bubblegum',
                             'xrf_parameter_user.json')
    # format the dictionary
    dct = format_dict(parameter_model.parameters, parameter_model.element_list)
    json_out = json.dumps(dct)
    with open(user_path, 'w') as out_file:
        out_file.write(json_out)


# to be deleted
enamldef ParameterEdit_old(Window):
    attr parameter_model
    attr param
    destroy_on_close = False
    Container:
        ComboBox: cmb:
            items << sorted(parameter_model.keys())
            selected_item ::
                #print(str(parameter_model[selected_item]['value']))
                param.name = selected_item
                param.value = parameter_model[selected_item]['value']
                param.min = parameter_model[selected_item]['min']
                param.max = parameter_model[selected_item]['max']
                param.fit_with_tail = parameter_model[selected_item]['fit_with_tail']
                param.free_more = parameter_model[selected_item]['free_more']
                param.adjust_element = parameter_model[selected_item]['adjust_element']
                param.e_calibration = parameter_model[selected_item]['e_calibration']
                param.linear = parameter_model[selected_item]['linear']

        Form:
            #Label: lb1:
            #    text = 'name'
            #Field: fd1:
            #    text = param.name
            Label: lb2:
                text = 'value'
            FloatField: fd2:
                value := param.value
            Label: lb3:
                text = 'min'
            FloatField: fd3:
                value := param.min
            Label: lb4:
                text = 'max'
            FloatField: fd4:
                value := param.max
            Label: lb5:
                text = 'fit_with_tail'
            Field: fd5:
                text := param.fit_with_tail
            Label: lb6:
                text = 'free_more'
            Field: fd6:
                text := param.free_more
            Label: lb7:
                text = 'e_calibration'
            Field: fd7:
                text := param.e_calibration
            Label: lb8:
                text = 'linear'
            Field: fd8:
                text := param.linear
            Label: lb9:
                text = 'adjust_element'
            Field: fd9:
                text := param.adjust_element

        #AutoView: av:
        #    model = parameter_model.values()[0]
        #    initialized ::
        #        pass
        #        #for o in objects:
        #        #    o.label.tool_tip = str(o)
        PushButton: save:
            text = "Save changes to disk"
            clicked ::
                pass
                #save_defaults(parameter_model)
